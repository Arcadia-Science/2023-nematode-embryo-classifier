import json
import logging
import pathlib
import click
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import sklearn.metrics

from embryostage.metadata import get_annotations_filepath
from embryostage.models import constants
from embryostage.models.data import EmbryoDataset

# set the font to Arcadia's default font
plt.rcParams["font.family"] = ["Suisse Int'l", "sans-serif"]

# blunt way to disable matplotlib's font-not-found warnings
# (which are very noisy and occur if the user does not have Arcadia's font installed)
logging.getLogger("matplotlib.font_manager").setLevel(logging.ERROR)


def _plot_confusion_matrix(true_labels, predicted_labels, labels):
    """
    plot the confusion matrix for the given true and predicted labels
    """

    confusion_matrix = sklearn.metrics.confusion_matrix(
        y_true=true_labels, y_pred=predicted_labels, labels=labels
    )

    # normalize the confusion matrix by row
    # (so that the rows corresponds to the distribution of predicted labels
    # for each true label)
    confusion_matrix = confusion_matrix.astype("float") / confusion_matrix.sum(axis=1)[:, None]

    # hack: replace NaNs with zeros
    # (these occur when there are no instances of a label in true_labels)
    confusion_matrix[np.isnan(confusion_matrix)] = 0

    plt.figure(figsize=(6, 6))
    labels_for_plot = [label.capitalize() for label in labels]
    sns.heatmap(
        confusion_matrix,
        annot=True,
        xticklabels=labels_for_plot,
        yticklabels=labels_for_plot,
        cmap="Blues",
        fmt=".2f",
        annot_kws={"size": 14},
        square=True,
        cbar=False,
    )

    plt.xticks(rotation=45, ha="right", fontsize=14, fontstyle="normal")
    plt.yticks(rotation=0, ha="right", fontsize=14, fontstyle="normal")

    plt.ylabel("True label", fontsize=16)
    plt.xlabel("Inferred label", fontsize=16)
    plt.title("Confusion matrix", fontsize=16)
    plt.tight_layout()


@click.option(
    "--predictions-filepath",
    type=pathlib.Path,
    help="The location of the predictions file (generated by batch_classify_embryos.py)",
)
@click.option(
    "--annotations-filepath",
    type=pathlib.Path,
    default=get_annotations_filepath(),
    help="The location of the annotations to use (defaults to the training annotations)",
)
@click.option(
    "--filename-suffix",
    type=str,
    default="",
    help="A suffix to add to the filename of the plot",
)
@click.option(
    "--labels-column",
    type=str,
    default="labels",
    help="The name of the column in the predictions file that contains the labels",
)
@click.command()
def main(predictions_filepath, annotations_filepath, filename_suffix, labels_column):
    """
    Plot the confusion matrix for the predictions from a trained model
    given a set of manual annotations, and save the plot as a PDF in the directory
    containing the predictions file

    Parameters
    ----------
    predictions_filepath: pathlib.Path
        The path to the JSON file of predictions generated by batch_classify_embryos.py
    annotations_filepath: pathlib.Path
        The path to the CSV file of manual annotations
        (defaults to the training annotations in ground_truth/training_annotations.csv)
    """

    # load the manual annotations
    embryo_dataset = EmbryoDataset(
        data_dirpath="",
        channel_names=["raw"],
        annotations_csv=annotations_filepath,
        dataset_ids=None,
    )
    annotations = embryo_dataset.labels_df.copy()

    annotations.rename(
        columns={"frame": "frame_ind", "stage": "annotated_label"}, inplace=True
    )

    # sanity check that the annotations are unique
    counts = annotations.groupby(["dataset_id", "fov_id", "embryo_id", "frame_ind"]).count()
    if any(counts.annotated_label > 1):
        ids = counts.loc[counts.annotated_label > 1].index.tolist()
        raise ValueError(
            f"The annotations for embryos {ids} have multiple labels for the same frame. "
            "Check that the annotations are unique."
        )

    with open(predictions_filepath, "r") as file:
        data = json.load(file)
    preds = pd.DataFrame(data)

    # add a frame index to the labels
    preds["labels"] = preds[labels_column]
    preds["labels"] = preds.labels.apply(lambda labels: list(enumerate(labels)))

    # explode on the labels and split the frame index and label name to separate columns
    preds = preds.explode("labels")
    preds["frame_ind"] = preds.labels.apply(lambda d: d[0])
    preds["predicted_label"] = preds.labels.apply(lambda d: d[1])

    # drop columns we won't need
    preds.drop(
        labels=["logits", "labels", "embryo_filepath"], axis=1, inplace=True, errors="ignore"
    )

    # the columns on which to merge the annotations and the predictions
    # (this is the set of columns that uniquely identify each timelapse frame)
    merge_columns = ["dataset_id", "fov_id", "embryo_id", "frame_ind"]

    # coerce the merge columns to strings
    for df in (annotations, preds):
        for column in merge_columns:
            df[column] = df[column].astype(str)

    # merge the predictions and the manual annotations
    annotations_preds_merged = pd.merge(
        annotations, preds, on=merge_columns, how="inner", validate="one_to_one"
    )
    if annotations_preds_merged.empty:
        raise ValueError(
            "No predictions found for the given annotations. "
            "Check that the predictions file and annotations file are for the same dataset."
        )

    _plot_confusion_matrix(
        true_labels=annotations_preds_merged.annotated_label.values,
        predicted_labels=annotations_preds_merged.predicted_label.values,
        labels=constants.EMBRYO_STAGE_LABELS,
    )

    filename_parts = [predictions_filepath.stem, "confusion-matrix", annotations_filepath.stem]
    if filename_suffix:
        filename_parts.append(filename_suffix)

    plt.savefig(
        predictions_filepath.parent / f"{'--'.join(filename_parts)}.pdf",
        format="pdf",
    )


if __name__ == "__main__":
    main()
